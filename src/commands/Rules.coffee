# CSS rules and conditions
GSS.Parser = require 'ccss-compiler'


class Rules
  # The wonderful semicolon
  # Executes each argument with current continuations
  # - Expressions dont affect each other
  # - Unresolved values dont stop other expressions from executing

  ';':
    prefix: ''
    noop: true
    evaluate: (arg, evaluated) ->
      return arg if arg.index == 0
      if arg.index == 1 || (evaluated[1] && arg.index == 2)
        value = @evaluate arg
        value = null if value == undefined
        return value

  
  # Comma combines found elements from multiple selectors without duplicates
  ',':
    # If all sub-selectors are native, make a single comma separated selector
    group: '$query'

    # Separate arguments with commas during serialization
    separator: ','

    serialized: true

    # Dont let undefined arguments stop execution
    eager: true

    # Commas disregard continuation path, because their path is global
    # - comma separated list of selectors. So we prepend scope id to disambiguate 
    serialize: (operation, scope) ->
      if scope && scope != @scope
        return @recognize(scope) + operation.path
      else
        return operation.path

    # Return deduplicated collection of all found elements
    command: (operation, continuation, scope) ->
      continuation = @commands[','].serialize.call(@, operation, scope)
      return @queries.get(continuation)

    # Recieve a single element found by one of sub-selectors
    # Duplicates are stored separately, they dont trigger callbacks
    capture: (result, operation, continuation, scope) -> 
      continuation = @commands[','].serialize.call(@, operation.parent, scope)
      @queries.add(result, continuation, operation.parent, scope)
      return true

    # Remove a single element that was found by sub-selector
    # Doesnt trigger callbacks if it was also found by other selector
    release: (result, operation, continuation, scope) ->
      debugger
      continuation = @commands[','].serialize.call(@, operation.parent, scope)
      @queries.remove(result, continuation, operation.parent, scope, true)
      return true

  # Conditionals
  
  "rule":
    bound: 1

    # Set rule body scope to a found element
    evaluate: (operation, continuation, scope, ascender, ascending) ->
      if operation.index == 2 && !ascender
        @expressions.evaluate operation, continuation, ascending, undefined, undefined, operation.parent
        return false

    # Capture commands generated by a conditional branch
    capture: (result, parent, continuation, scope) ->
      if !result.nodeType && !@isCollection(result)
        @expressions.push result
        return true

  "if":
    # Resolve all values in first argument
    primitive: 1

    cleaning: true

    subscribe: (operation, continuation, scope) ->
      id = scope._gss_id
      watchers = @queries._watchers[id] ||= []
      if !watchers.length || @values.indexOf(watchers, operation, continuation, scope) == -1
        watchers.push operation, continuation, scope

    # Capture commands generated by a conditional branch
    capture: (result, operation, continuation, scope) ->
      # Result of condition bubbled up,
      debugger
      if operation.index == 1

        @commands.if.branch.call(@, operation.parent[1], continuation, scope, undefined, result)
        return true
      else
      # Capture commands bubbled up from branches
        if typeof result == 'object' && !result.nodeType && !@isCollection(result)
          @expressions.push result
          return true

    branch: (operation, continuation, scope, ascender, ascending) ->
      @commands.if.subscribe.call(@, operation.parent, continuation, scope)
      operation.parent.uid ||= '@' + (@commands.uid = (@commands.uid ||= 0) + 1)
      condition = ascending && (typeof ascending != 'object' || ascending.length != 0)
      path = continuation + operation.parent.uid
      query = @queries[path]
      if query == undefined || (!!query != !!condition)
        console.group(path)
        unless query == undefined
          @queries.clean(path, continuation, operation.parent, scope)
        if condition
          @expressions.evaluate operation.parent[2], path, scope
        else if operation.parent[3]
          @expressions.evaluate operation.parent[3], path, scope
        console.groupEnd(path)

        @queries[path] = condition ? null

  "text/gss-ast": (source) ->
    return JSON.parse(source)

  "text/gss": (source) ->
    return GSS.Parser.parse(source)?.commands

  "eval": 
    command: (operation, continuation, scope, node, type = 'text/gss', source) ->
      rules = @['_' + (node.type || type)](source ? node.textContent ? node)
      scope = node.nodeType && node.getAttribute('scoped')? && node.parentNode || @scope
      console.log('Eval', rules, continuation)
      debugger
      rules = GSS.clone(rules)
      @run rules, continuation + 'â€¦', scope
      return

  "load": 
    command: (operation, continuation, scope, node, type, method = 'GET') ->
      src = node.href || node.src || node
      type ||= node.type || 'text/gss'
      xhr = new XMLHttpRequest()
      xhr.onreadystatechange = =>
        if xhr.readyState == 4
          if xhr.status == 200
            @_eval.command.call(@, operation, continuation, scope, node, type, xhr.responseText)
      xhr.open(method.toUpperCase(), src)
      xhr.send()

for property, fn of Rules::
  fn.rule = true



module.exports = Rules