# CSS rules and conditions
compiler = require 'gss-compiler'

class Rules
  # The wonderful semicolon
  # Executes each argument with current continuations
  # - Expressions dont affect each other
  # - Unresolved values dont stop other expressions from executing

  ';':
    prefix: ''
    noop: true
    evaluate: (arg, evaluated) ->
      return arg if arg.index == 0
      if arg.index == 1 || (evaluated[1] && arg.index == 2)
        value = @evaluate arg
        value = null if value == undefined
        return value

  
  # Conditionals
  
  "$rule":
    # Set rule body scope to a found element
    evaluate: (operation, continuation, scope, ascender, ascending) ->
      if operation.index == 2 && !ascender
        @expressions.evaluate operation, continuation, ascending, undefined, undefined, operation.parent
        return false

    # Capture commands generated by a conditional branch
    capture: (result, parent, continuation, scope) ->
      if !result.nodeType && !@isCollection(result)
        @expressions.push result
        return true

  "$if":
    # Resolve all values in first argument
    primitive: 1

    subscribe: (operation, continuation, scope) ->
      id = scope._gss_id
      watchers = @queries._watchers[id] ||= []
      if !watchers.length || @values.indexOf(watchers, operation, continuation, scope) == -1
        watchers.push operation, continuation, scope

    # Capture commands generated by a conditional branch
    capture: (result, operation, continuation, scope) ->
      # Result of condition bubbled up,
      if operation.index == 1

        @commands.$if.branch.call(@, operation.parent[1], continuation, scope, undefined, result)
        return true
      else
      # Capture commands bubbled up from branches
        console.log('kapture', result)
        if typeof result == 'object' && !result.nodeType && !@isCollection(result)
          @expressions.push result
          return true

    branch: (operation, continuation, scope, ascender, ascending) ->
      @commands.$if.subscribe.call(@, operation.parent, continuation, scope)
      operation.parent.uid ||= '@' + (@commands.uid = (@commands.uid ||= 0) + 1)
      condition = ascending && (typeof ascending != 'object' || ascending.length != 0)
      path = continuation + operation.parent.uid
      if @queries[path] == undefined || (!!@queries[path] != !!condition)
        console.group(path)
        unless @queries[path] == undefined
          console.error('clean', [path, continuation])
          @queries.clean(path, continuation, operation, scope)
        if condition
          @expressions.evaluate operation.parent[2], path, scope
        else if operation.parent[3]
          @expressions.evaluate operation.parent[3], path, scope
        console.groupEnd(path)

        @queries[path] = condition ? null


  "$eval": (node, type = 'text/gss') ->
    if (node.type || type) == 'text/gss-ast'
      rules = JSON.parse(node.textContent ? node)
    else
      rules = compiler.compile(node.textContent ? node)
    scope = node.nodeType && node.getAttribute('scoped')? && node.parentNode || @scope
    @run rules, undefined, scope
    return

  "$load": (node, type, method = 'GET') ->
    src = node.href || node.src || node
    type ||= node.type || 'text/gss'
    xhr = new XMLHttpRequest()
    xhr.onstatechange = ->
      if xhr.readyState == 4
        if xhr.status == 200
          1
    xhr.open(node.toUpperCase(), src)





module.exports = Rules