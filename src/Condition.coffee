Command = require('./Command')

class Condition extends Command
  type: 'Condition'
  
  signature: [
  	if: ['Query', 'Selector', 'Variable', 'Constraint', 'Default'],
  	then: ['Any'], 
  	[
  		else: ['Any']
  	]
  ]

  cleaning: true

  domain: 'solved'

  constructor: (operation, engine) ->
    @key ||= @serialize(operation, engine)
    if @linked
      if parent = operation.parent
        previous = parent[parent.indexOf(operation) - 1]
        if command = previous.command
          if command.type == 'Condition'
            command.next = operation
            @previous = command


  push: ->

  serialize: (operation, engine) ->
    return '@' + @toExpression(operation[1])

  update: (engine, operation, continuation, scope, ascender, ascending) ->

    if watchers = engine.queries?.watchers
      watchers = watchers[scope._gss_id] ||= []
      if !watchers.length || engine.indexOfTriplet(watchers, operation.parent, continuation, scope) == -1
        watchers.push operation.parent, continuation + @DESCEND, scope

    
    path = continuation + @DESCEND + @key

    old = @value
    if !!old != !!ascending || (old == undefined && old != ascending)
      
      unless old == undefined
        engine.Query::clean(engine, path, continuation, operation.parent, scope)
      unless engine.switching
        switching = engine.switching = true

      @value = ascending
      if switching
        engine.triggerEvent('switch', operation, path)

        if engine.updating
          collections = engine.updating.collections
          engine.updating.collections = {}
          engine.updating.previous = collections

      index = ascending ^ @inverted && 2 || 3
      engine.console.group '%s \t\t\t\t%o\t\t\t%c%s', (index == 2 && 'if' || 'else') + @DESCEND, operation.parent[index], 'font-weight: normal; color: #999', continuation
      if branch = operation.parent[index]
        result = engine.Command(branch).solve(engine, branch, @delimit(path, @DESCEND), scope)

      if switching
        engine.triggerEvent('switch', operation, true)
        engine.switching = undefined
      
      engine.console.groupEnd(path)

  # Capture commands generated by evaluation of arguments
  yield: (result, engine, operation, continuation, scope) ->
    # Condition result bubbled up, pick a branch
    if operation.parent.indexOf(operation) == -1
      if operation[0].key
        continuation = operation[0].key
        scope = engine.identity[operation[0].scope] || scope
      else
        continuation = @delimit(continuation, @DESCEND)
      if continuation?
        @update(engine.document || engine.abstract, operation.parent[1], continuation, scope, undefined, result)
      return true

# Detect condition that only observes variables outside of current scope
Condition.Global = Condition.extend

  condition: (engine, operation, command) ->
    if command
      operation = operation[1]
    if operation[0] == 'get'
      if operation.length == 2 || operation[1][0] == '&'
        return false
    for argument in operation
      if argument && argument.push && @condition(engine, argument) == false
        return false
    return true



  global: true

Condition::advices = [Condition.Global]

Condition.define 'if', {}
Condition.define 'unless', {
  inverted: true
}
Condition.define 'else', {
  signature: [
    then: ['Any']
  ]

  linked: true

  solve: ->
    return true
}
Condition.define 'elseif', {
  linked: true
}
Condition.define 'elsif', {
}
 
module.exports = Condition